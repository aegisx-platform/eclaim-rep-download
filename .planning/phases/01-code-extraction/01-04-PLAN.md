---
phase: 01-code-extraction
plan: 04
type: execute
---

<objective>
Extract STM (Statement) downloader to eclaim_core with CLI tool.

Purpose: Create the STMDownloader class that handles statement file downloads from NHSO.
Output: Working STMDownloader class and cli/download_stm.py CLI tool.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-code-extraction/01-03-SUMMARY.md

**Source file to extract:**
@stm_downloader_http.py

**Pattern reference:**
Reference: ../eclaim-downloader-core/eclaim_core/downloaders/rep.py (follow same pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract STMDownloader class</name>
  <files>
../eclaim-downloader-core/eclaim_core/downloaders/stm.py
../eclaim-downloader-core/eclaim_core/downloaders/__init__.py
  </files>
  <action>
Extract and refactor `stm_downloader_http.py` to create STMDownloader class.

Key changes:
1. Inherit from BaseDownloader
2. Follow same pattern as REPDownloader
3. Handle fiscal year logic (October-September)
4. Support UCS, OFC, SSS, LGO schemes only
5. Support person type filtering (IP, OP, All)
6. Use eclaim_core.types for enums and dataclasses

**stm.py structure:**
```python
"""
STM (Statement) Downloader
Downloads payment statement files from NHSO E-Claim portal.
"""

import os
import time
from typing import List, Optional, Dict, Any
from datetime import datetime
from bs4 import BeautifulSoup
import requests

from .base import BaseDownloader
from ..types import (
    DownloadType, FileType, Scheme,
    DownloadResult, DownloadProgress, DownloadLink
)


class STMDownloader(BaseDownloader):
    """
    Downloads STM (Statement) files from NHSO E-Claim portal.
    Handles payment/reimbursement statements for various schemes.
    """

    BASE_URL = "https://eclaim.nhso.go.th"
    LOGIN_URL = f"{BASE_URL}/webComponent/mainloginAction.do"

    # Only these schemes support STM
    SUPPORTED_SCHEMES = [Scheme.UCS, Scheme.OFC, Scheme.SSS, Scheme.LGO]

    SCHEME_URLS = {
        Scheme.UCS: "/webComponent/ucs/statementUCSAction.do",
        Scheme.OFC: "/webComponent/ofc/statementOFCAction.do",
        Scheme.SSS: "/webComponent/sss/statementSSSAction.do",
        Scheme.LGO: "/webComponent/lgo/statementLGOAction.do",
    }

    def __init__(
        self,
        fiscal_year: Optional[int] = None,  # Buddhist Era
        month: Optional[int] = None,
        schemes: Optional[List[Scheme]] = None,
        person_type: str = "All",  # IP, OP, or All
        **kwargs
    ):
        super().__init__(**kwargs)
        self.fiscal_year = fiscal_year or self._current_fiscal_year()
        self.month = month  # None means entire fiscal year
        self.schemes = schemes or [Scheme.UCS]
        self.person_type = person_type

        # Validate schemes
        self.schemes = [s for s in self.schemes if s in self.SUPPORTED_SCHEMES]

    @property
    def download_type(self) -> DownloadType:
        return DownloadType.STM

    @staticmethod
    def _current_fiscal_year() -> int:
        """
        Get current fiscal year in Buddhist Era.
        Fiscal year runs October to September.
        """
        now = datetime.now()
        year_be = now.year + 543
        # If before October, we're in previous fiscal year
        if now.month < 10:
            return year_be
        return year_be + 1

    def login(self, username: str, password: str) -> bool:
        """Authenticate with NHSO E-Claim portal."""
        self.session = self._create_session()

        try:
            self.session.get(self.LOGIN_URL, timeout=30)
            response = self.session.post(
                self.LOGIN_URL,
                data={'user': username, 'pass': password},
                timeout=30
            )

            if 'login' in response.url.lower() and 'error' in response.text.lower():
                self._log("Login failed - invalid credentials", level='error')
                return False

            self._log("Login successful", level='success')
            return True

        except requests.RequestException as e:
            self._log(f"Login error: {e}", level='error')
            return False

    def get_download_links(self, **kwargs) -> List[DownloadLink]:
        """Get download links for configured fiscal year/schemes."""
        links = []

        for scheme in self.schemes:
            scheme_links = self._get_scheme_links(scheme)
            links.extend(scheme_links)
            self._log(f"Found {len(scheme_links)} STM files for {scheme.value.upper()}")

        return links

    def _get_scheme_links(self, scheme: Scheme) -> List[DownloadLink]:
        """Get download links for a specific scheme."""
        if scheme not in self.SCHEME_URLS:
            return []

        url = f"{self.BASE_URL}{self.SCHEME_URLS[scheme]}"
        params = {
            'year': str(self.fiscal_year),
            'method': 'statement'
        }

        if self.month:
            params['month'] = str(self.month)

        if self.person_type != "All":
            params['personType'] = self.person_type

        try:
            response = self.session.get(url, params=params, timeout=30)
            response.raise_for_status()
            return self._parse_download_links(response.text, scheme)
        except requests.RequestException as e:
            self._log(f"Error fetching STM links for {scheme.value}: {e}", level='error')
            return []

    def _parse_download_links(self, html: str, scheme: Scheme) -> List[DownloadLink]:
        """Parse HTML to extract download links."""
        soup = BeautifulSoup(html, 'html.parser')
        links = []

        for link in soup.find_all('a', href=True):
            href = link['href']
            if 'download' in href.lower() or 'excel' in href.lower():
                filename = self._extract_filename(href, link.text)
                if filename:
                    full_url = href if href.startswith('http') else f"{self.BASE_URL}{href}"
                    file_type = self._detect_file_type(filename)
                    links.append(DownloadLink(
                        url=full_url,
                        filename=filename,
                        file_type=file_type,
                        scheme=scheme
                    ))

        return links

    def _extract_filename(self, href: str, link_text: str) -> Optional[str]:
        """Extract filename from URL or link text."""
        for param in ['fn', 'filename', 'file']:
            if f'{param}=' in href:
                parts = href.split(f'{param}=')
                if len(parts) > 1:
                    filename = parts[1].split('&')[0]
                    if filename:
                        return filename

        text = link_text.strip()
        if text and '.xls' in text.lower():
            return text

        return None

    def _detect_file_type(self, filename: str) -> Optional[FileType]:
        """Detect file type from filename."""
        filename_upper = filename.upper()
        if '_IP' in filename_upper or 'IP_' in filename_upper:
            return FileType.STM_IP
        elif '_OP' in filename_upper or 'OP_' in filename_upper:
            return FileType.STM_OP
        return None

    def download_file(self, link: DownloadLink) -> DownloadResult:
        """Download a single STM file."""
        file_path = os.path.join(self.download_dir, link.filename)

        # Check if already downloaded
        if self.history and self.history.exists(link.filename):
            return DownloadResult(
                success=False,
                filename=link.filename,
                file_path=file_path,
                file_size=0,
                download_type=self.download_type,
                file_type=link.file_type,
                scheme=link.scheme,
                year=self.fiscal_year,
                error="skipped"
            )

        # Download with retry
        max_retries = 2
        for attempt in range(max_retries + 1):
            try:
                response = self.session.get(link.url, stream=True, timeout=60)
                response.raise_for_status()

                with open(file_path, 'wb') as f:
                    for chunk in response.iter_content(chunk_size=8192):
                        f.write(chunk)

                file_size = os.path.getsize(file_path)

                if file_size < 100:
                    raise ValueError("File too small, likely error page")

                return DownloadResult(
                    success=True,
                    filename=link.filename,
                    file_path=file_path,
                    file_size=file_size,
                    download_type=self.download_type,
                    file_type=link.file_type,
                    scheme=link.scheme,
                    year=self.fiscal_year,
                    url=link.url
                )

            except Exception as e:
                if attempt < max_retries:
                    self._log(f"Retry {attempt + 1}/{max_retries}: {e}", level='warning')
                    time.sleep(2)
                else:
                    return DownloadResult(
                        success=False,
                        filename=link.filename,
                        file_path=file_path,
                        file_size=0,
                        download_type=self.download_type,
                        error=str(e)
                    )

    def run(self, username: str, password: str) -> Dict[str, Any]:
        """Execute full STM download workflow."""
        if not self.login(username, password):
            return {'success': False, 'error': 'Login failed'}

        links = self.get_download_links()
        if not links:
            return {'success': True, 'downloaded': 0, 'skipped': 0, 'errors': 0}

        results = self.download_all(links)

        downloaded = sum(1 for r in results if r.success)
        skipped = sum(1 for r in results if r.error == 'skipped')
        errors = sum(1 for r in results if r.error and r.error != 'skipped')

        return {
            'success': True,
            'downloaded': downloaded,
            'skipped': skipped,
            'errors': errors,
            'total': len(results)
        }
```

Update `eclaim_core/downloaders/__init__.py` to add STMDownloader:
```python
"""Downloader implementations."""
from .base import BaseDownloader
from .rep import REPDownloader
from .stm import STMDownloader

__all__ = ["BaseDownloader", "REPDownloader", "STMDownloader"]
```
  </action>
  <verify>`cd ../eclaim-downloader-core && python -c "from eclaim_core.downloaders import STMDownloader; d = STMDownloader(); print(d.download_type)"`</verify>
  <done>STMDownloader class extracted and working</done>
</task>

<task type="auto">
  <name>Task 2: Create CLI tool for STM downloads</name>
  <files>
../eclaim-downloader-core/cli/download_stm.py
  </files>
  <action>
Create a CLI tool for STM downloads using argparse.

**cli/download_stm.py:**
```python
#!/usr/bin/env python3
"""
STM Download CLI Tool
Download statement files from NHSO E-Claim portal.

Usage:
    python -m cli.download_stm --fiscal-year 2569 --schemes ucs ofc
    python -m cli.download_stm --month 1 --person-type IP
    python -m cli.download_stm --help
"""

import argparse
import sys

from eclaim_core.downloaders import STMDownloader
from eclaim_core.config import SettingsManager
from eclaim_core.history import HistoryManager
from eclaim_core.logging import LogStreamer
from eclaim_core.types import Scheme


def parse_args():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="Download STM (Statement) files from NHSO E-Claim portal"
    )

    # Date options
    parser.add_argument(
        '--fiscal-year', '-y',
        type=int,
        help="Fiscal year in Buddhist Era (default: current)"
    )
    parser.add_argument(
        '--month', '-m',
        type=int,
        help="Specific month (1-12), omit for entire fiscal year"
    )

    # Scheme options
    parser.add_argument(
        '--schemes', '-s',
        nargs='+',
        default=['ucs'],
        choices=['ucs', 'ofc', 'sss', 'lgo'],
        help="Insurance schemes (default: ucs). Only ucs/ofc/sss/lgo support STM."
    )

    # Person type
    parser.add_argument(
        '--person-type', '-t',
        default='All',
        choices=['IP', 'OP', 'All'],
        help="Person type filter (default: All)"
    )

    # Credential options
    parser.add_argument(
        '--username', '-u',
        help="NHSO username (or set ECLAIM_USERNAME env var)"
    )
    parser.add_argument(
        '--password', '-p',
        help="NHSO password (or set ECLAIM_PASSWORD env var)"
    )

    # Output options
    parser.add_argument(
        '--download-dir', '-d',
        default='./downloads',
        help="Download directory (default: ./downloads)"
    )
    parser.add_argument(
        '--quiet', '-q',
        action='store_true',
        help="Suppress output"
    )

    return parser.parse_args()


def main():
    """Main entry point."""
    args = parse_args()

    # Initialize components
    settings = SettingsManager()
    history = HistoryManager(
        stm_history_file="stm_download_history.json"
    )
    logger = LogStreamer() if not args.quiet else None

    # Get credentials
    username = args.username or settings.get('eclaim_username')
    password = args.password or settings.get('eclaim_password')

    if not username or not password:
        print("Error: Username and password required")
        print("Set via --username/--password or ECLAIM_USERNAME/ECLAIM_PASSWORD env vars")
        sys.exit(1)

    # Convert scheme strings to enums
    schemes = [Scheme(s) for s in args.schemes]

    # Create downloader
    downloader = STMDownloader(
        fiscal_year=args.fiscal_year,
        month=args.month,
        schemes=schemes,
        person_type=args.person_type,
        download_dir=args.download_dir,
        history_manager=history,
        logger=logger
    )

    # Run download
    print(f"Downloading STM files for fiscal year {downloader.fiscal_year}")
    if args.month:
        print(f"Month: {args.month}")
    print(f"Schemes: {', '.join(args.schemes)}")
    print(f"Person type: {args.person_type}")
    print(f"Download directory: {args.download_dir}")
    print("-" * 40)

    result = downloader.run(username, password)

    if not result.get('success'):
        print(f"Error: {result.get('error', 'Unknown error')}")
        sys.exit(1)

    print("-" * 40)
    print(f"Downloaded: {result['downloaded']}")
    print(f"Skipped: {result['skipped']}")
    print(f"Errors: {result['errors']}")
    print(f"Total: {result['total']}")

    # Save history
    history.save()


if __name__ == '__main__':
    main()
```
  </action>
  <verify>`cd ../eclaim-downloader-core && python -m cli.download_stm --help` shows usage</verify>
  <done>CLI tool created and shows help</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] STMDownloader class imports correctly
- [ ] STMDownloader inherits from BaseDownloader
- [ ] CLI tool shows help: `python -m cli.download_stm --help`
- [ ] CLI tool accepts fiscal-year/schemes/person-type arguments
</verification>

<success_criteria>
- STMDownloader fully extracted with fiscal year logic
- CLI tool functional with STM-specific options
- Ready for SMT fetcher extraction
</success_criteria>

<output>
After completion, create `.planning/phases/01-code-extraction/01-04-SUMMARY.md`
</output>
